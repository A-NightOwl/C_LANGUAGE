埃拉托斯特尼筛法（Sieve of Eratosthenes）：这是一种高效的找出一定范围内所有素数的方法，通过预先筛选出所有素数，可以避免对每个数都进行素数判断
**题**  
“这是我和其他选手比谁过题过得更快的游戏”
```
对于任何大于或等于4的偶数n，存在至少一对素数p1和p2，使得n = p1 + p2
没有人确定这个猜想是否真的成立。然而，对于给定的偶数，可以找到这样的一对素数（如果有的话）。这里的问题是编写一个程序，打印出满足给定偶数的猜想条件的所有素数对数。

一个偶数序列作为输入。可以有很多这样的数字。对应于每个数字，程序应输出上述对的数量。请注意，我们只统计不同的数对，因此不应将（p1，p2）和（p2，p1）分别计为两对不同的对。
```
**输入格式:**  
在每个输入行中给出一个整数。你可以假定每个整数是偶数，并且大于或等于4且小于2的15次方。输入的结尾用数字0表示。

**输出格式:**  
每个输出行应该包含一个整数。输出中不应出现其他字符。

**输入样例:**    
在这里给出一组输入。例如：  
6    
10  
12  
0

**输出样例:**  
在这里给出相应的输出。例如：  
1  
2  
1

```c
#include <stdio.h>
 
int main()
{
    int n, i, j, x, count;
 
    scanf("%d",&n);
 
    while(n != 0)
    {
        int a[n];
        for(i = 0; i < n; i++)      //先将数组所有元素赋值为1
        {
            a[i] = 1;
        }
        for(i = 2; i <= n/2; i++)   //通过筛选法求素数将不是素数下表的元素改为0
        {
            for(j = i; j*i < n; j++)
            {
                a[i*j] = 0;
            }
        }
        count = 0;                   //计数每当两个数相加等于n时，count+1
        for(i = 2; i <= n/2; i++)
        {
            if(a[i] == 1 && a[n-i] == 1)
                count++;
        }
 
        printf("%d\n",count);
        scanf("%d", &n);
    }
 
}
```