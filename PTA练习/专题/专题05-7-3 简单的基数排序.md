桶式排序是一种简单的基数排序。桶式排序（这里以对若干个正整数的排序为例描述求解过程）：待排序的正整数存放在一维数组中，此外还有一个整型的二维数组，其中行下标从0～9，列下标从0～n – 1。在这里，n是待排序的数组中元素的数目。二维数组的每行称为一个桶。编写一个程序，读入15个正整数，并按从小到大的顺序排序。桶式排序的算法如下：  

遍历一维数组中的每个元素，并根据它的个位将每个值安排在桶数组的某行中。例如，97安排在行7，3安排在行3，而100安排在行0——这个过程叫分桶。  

在桶数组内循环，并将值复制回到最初的数组——这个过程叫收集。上面的数值在一维数组中的新顺序是100、3和97。

接下来依次取一维数组中所有数字的十位，百位，千位等等，并按取出的十位，百位，千位等位上的数字不断分桶和放回原数组；重复这个过程（分桶---收集），当处理完了一维数组中最大数字的最高位时，就停止这个过程。

例如，在对数组进行第2轮处理时，100安排在行0，3安排在行0（它仅有一个数位），而97安排在行9。一维数组中值的顺序是100、3和97。在第3轮处理时，100安排在行1，3安排在行0，而97安排在行0（在3之后）。桶式排序可以确保在处理了最大数字的最高位之后正确排列所有值的顺序。

注意，桶的二维数组的大小是要排序的整数数组大小的10倍。这种排序方法的性能比冒泡排序方法要高，但需要更多的存储空间。冒泡排序仅仅需要为待排序的数据配置内存空间，整个排序过程中不再需要额外的空间；然而，桶式排序中待排数据需要存放空间，此外排序过程中用到的桶也需要内存空间。桶式排序使用更多的内存，但性能更好，这是一种以空间换时间的做法。
本题目源自重庆科技学院的伍建全老师，在此特向伍老师致谢！！！

**输入格式:**  
输入为15个不超出int数值范围的非负整数。

**输出格式:**  
运用上面介绍的桶排序规则编制程序，输出每次分派收集之后得到的一维数组，每个整数之间以空格隔开。每次输出占一行。（注意每行末尾有1个空格）

**输入样例:**  
在这里给出一组输入。例如：

6634 9796 435 1405 6123 10001 11459 12018 10372 19874 12860 11326 7096 30205 27010  

**输出样例:**  
在这里给出相应的输出。例如：

12860 27010 10001 10372 6123 6634 19874 435 1405 30205 9796 11326 7096 12018 11459   
10001 1405 30205 27010 12018 6123 11326 6634 435 11459 12860 10372 19874 9796 7096   
10001 27010 12018 7096 6123 30205 11326 10372 1405 435 11459 6634 9796 12860 19874   
10001 30205 10372 435 11326 1405 11459 12018 12860 6123 6634 27010 7096 9796 19874   
435 1405 6123 6634 7096 9796 10001 10372 11326 11459 12018 12860 19874 27010 30205 



---
**自己写的**
```c
#include<stdio.h>
//函数声明
int Size_Max(int* arr);
void Bucket_INIT(int(*bucket)[15]);
void Bucket_Sort(int(*bucket)[15], int* arr, int size);
void Copy_Print(int* arr, int(*bucket)[15]);

//找出最大数字的最高位
int Size_Max(int* arr)
{
    int max=0,count=0;
    for(int i=0;i<15;i++)
    {
        if(arr[i]>max)
        {
            max=arr[i];
        }
    }
    while(max)
    {
        max/=10;
        count++;
    }
    return count;
}
//桶数组(bucket)初始化
void Bucket_INIT(int(* bucket)[15])
{
    for(int i=0;i<10;i++)
    {
        for(int j=0;j<15;j++)
        {
            bucket[i][j]=-1;
        }
    }
}
//原数组分桶
void Bucket_Sort(int(* bucket)[15],int* arr,int size)
{
    
    for(int i=1;i<=size;i++)
    {
        Bucket_INIT(bucket);
        int index=0;
        int pos=1;
        for(int j=1;j<i;j++)
            pos*=10;
        for(int j=0;j<15;j++)
        {
            bucket[arr[j]/pos%10][index++]=arr[j];
        }
        Copy_Print(arr,bucket);
    }
}
//原数组的收集与打印
void Copy_Print(int* arr,int(* bucket)[15])
{
    int index = 0;
    for(int i=0;i<10;i++)
    {
        for(int j=0;j<15;j++)
        {
            if(bucket[i][j]>=0)
            {
                arr[index++]=bucket[i][j];
                if(15==index)
                    break;
            }
            if(15==index)
                    break;
        }
    }
    for(int i=0;i<15;i++)
    {
        printf("%d ",arr[i]);
    }
    printf("\n");
}

int main()
{
    int arr[15];
    int bucket[10][15]={0};
    for(int i=0;i<15;i++)
    {
        scanf("%d",&arr[i]);
    }

    Bucket_Sort(bucket,arr,Size_Max(arr));

    return 0;
}
```